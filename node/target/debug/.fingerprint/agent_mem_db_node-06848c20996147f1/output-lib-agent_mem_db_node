{"$message_type":"diagnostic","message":"the name `AgentMemDB` is defined multiple times","code":{"code":"E0255","explanation":"You can't import a value whose name is the same as another value defined in the\nmodule.\n\nErroneous code example:\n\n```compile_fail,E0255\nuse bar::foo; // error: an item named `foo` is already in scope\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nYou can use aliases in order to fix this error. Example:\n\n```\nuse bar::foo as bar_foo; // ok!\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nOr you can reference the item with its parent:\n\n```\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {\n    bar::foo(); // we get the item by referring to its parent\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2323,"byte_end":2344,"line_start":88,"line_end":88,"column_start":1,"column_end":22,"is_primary":true,"text":[{"text":"pub struct AgentMemDB {","highlight_start":1,"highlight_end":22}],"label":"`AgentMemDB` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":19,"byte_end":29,"line_start":1,"line_end":1,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"use agent_mem_db::{AgentMemDB, Episode as RustEpisode, QueryOptions};","highlight_start":20,"highlight_end":30}],"label":"previous import of the type `AgentMemDB` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`AgentMemDB` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"you can use `as` to change the binding name of the import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":29,"byte_end":29,"line_start":1,"line_end":1,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"use agent_mem_db::{AgentMemDB, Episode as RustEpisode, QueryOptions};","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":" as OtherAgentMemDB","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0255]\u001b[0m\u001b[1m: the name `AgentMemDB` is defined multiple times\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:88:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use agent_mem_db::{AgentMemDB, Episode as RustEpisode, QueryOptions};\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mprevious import of the type `AgentMemDB` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`AgentMemDB` redefined here\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `AgentMemDB` must be defined only once in the type namespace of this module\n\u001b[1m\u001b[96mhelp\u001b[0m: you can use `as` to change the binding name of the import\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m| \u001b[0muse agent_mem_db::{AgentMemDB\u001b[92m as OtherAgentMemDB\u001b[0m, Episode as RustEpisode, QueryOptions};\n   \u001b[1m\u001b[94m|\u001b[0m                               \u001b[92m++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for arbitrary types","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for arbitrary types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for arbitrary types","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for arbitrary types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for arbitrary types","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for arbitrary types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for arbitrary types","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for arbitrary types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2334,"byte_end":2344,"line_start":88,"line_end":88,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"pub struct AgentMemDB {","highlight_start":12,"highlight_end":22}],"label":"`agent_mem_db::AgentMemDB` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2315,"byte_end":2322,"line_start":87,"line_end":87,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:87:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94m`agent_mem_db::AgentMemDB` is not defined in the current crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"cannot define inherent `impl` for a type outside of the crate where the type is defined","code":{"code":"E0116","explanation":"An inherent implementation was defined for a type outside the current crate.\n\nErroneous code example:\n\n```compile_fail,E0116\nimpl Vec<u8> { } // error\n```\n\nYou can only define an inherent implementation for a type in the same crate\nwhere the type was defined. For example, an `impl` block as above is not allowed\nsince `Vec` is defined in the standard library.\n\nTo fix this problem, you can either:\n\n - define a trait that has the desired associated functions/types/constants and\n   implement the trait for the type in question\n - define a new type wrapping the type and define an implementation on the new\n   type\n\nNote that using the `type` keyword does not work here because `type` only\nintroduces a type alias:\n\n```compile_fail,E0116\ntype Bytes = Vec<u8>;\n\nimpl Bytes { } // error, same as above\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2413,"byte_end":2428,"line_start":93,"line_end":93,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"impl AgentMemDB {","highlight_start":1,"highlight_end":16}],"label":"impl for type defined outside of crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0116]\u001b[0m\u001b[1m: cannot define inherent `impl` for a type outside of the crate where the type is defined\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:93:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m impl AgentMemDB {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimpl for type defined outside of crate\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":197,"byte_end":212,"line_start":7,"line_end":7,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":197,"byte_end":212,"line_start":7,"line_end":7,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `napi::bindgen_prelude::Object::<'_>::get`","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs","byte_start":23154,"byte_end":23167,"line_start":736,"line_end":736,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"  pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {","highlight_start":17,"highlight_end":30}],"label":"required by this bound in `Object::<'_>::get`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:7:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi(object)]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n              f64\n              i16\n              i32\n              i64\n              i8\n              u16\n              u32\n              u8\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `napi::bindgen_prelude::Object::<'_>::get`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs:736:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m736\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Object::<'_>::get`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1375,"byte_end":1383,"line_start":51,"line_end":51,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"    state_embedding: Vec<f32>,","highlight_start":22,"highlight_end":30}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:51:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     state_embedding: Vec<f32>,\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n             f64\n             i16\n             i32\n             i64\n             i8\n             u16\n             u32\n             u8\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1397,"byte_end":1400,"line_start":52,"line_end":52,"column_start":13,"column_end":16,"is_primary":true,"text":[{"text":"    reward: f32,","highlight_start":13,"highlight_end":16}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:52:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     reward: f32,\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n             f64\n             i16\n             i32\n             i64\n             i8\n             u16\n             u32\n             u8\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `usize: ToNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2137,"byte_end":2142,"line_start":80,"line_end":80,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    pub top_k: usize,","highlight_start":9,"highlight_end":14}],"label":"the trait `napi::JsValue<'_>` is not implemented for `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `napi::JsValue<'env>`:\n  ArrayBuffer<'env>\n  BufferSlice<'env>\n  ClassInstance<'env, T>\n  Float32ArraySlice<'env>\n  Float64ArraySlice<'env>\n  Int16ArraySlice<'env>\n  Int32ArraySlice<'env>\n  Int8ArraySlice<'env>\nand 18 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `usize` to implement `ToNapiValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `usize: ToNapiValue` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:80:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi(object)]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub top_k: usize,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::JsValue<'_>` is not implemented for `usize`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::JsValue<'env>`:\n             ArrayBuffer<'env>\n             BufferSlice<'env>\n             ClassInstance<'env, T>\n             Float32ArraySlice<'env>\n             Float64ArraySlice<'env>\n             Int16ArraySlice<'env>\n             Int32ArraySlice<'env>\n             Int8ArraySlice<'env>\n           and 18 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `usize` to implement `ToNapiValue`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `napi::bindgen_prelude::Object::<'_>::get`","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs","byte_start":23154,"byte_end":23167,"line_start":736,"line_end":736,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"  pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {","highlight_start":17,"highlight_end":30}],"label":"required by this bound in `Object::<'_>::get`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:77:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi(object)]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n              f64\n              i16\n              i32\n              i64\n              i8\n              u16\n              u32\n              u8\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `napi::bindgen_prelude::Object::<'_>::get`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs:736:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m736\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Object::<'_>::get`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `usize: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2060,"byte_end":2075,"line_start":77,"line_end":77,"column_start":1,"column_end":16,"is_primary":false,"text":[{"text":"#[napi(object)]","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `napi::bindgen_prelude::Object::<'_>::get`","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs","byte_start":23154,"byte_end":23167,"line_start":736,"line_end":736,"column_start":17,"column_end":30,"is_primary":true,"text":[{"text":"  pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {","highlight_start":17,"highlight_end":30}],"label":"required by this bound in `Object::<'_>::get`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `usize: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:77:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi(object)]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `usize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n              f64\n              i16\n              i32\n              i64\n              i8\n              u16\n              u32\n              u8\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `napi::bindgen_prelude::Object::<'_>::get`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-3.8.3/src/bindgen_runtime/js_values/object.rs:736:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m736\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub fn get<V: FromNapiValue>(&self, field: &str) -> Result<Option<V>> {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Object::<'_>::get`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"struct `agent_mem_db::AgentMemDB` has no field named `inner`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2518,"byte_end":2523,"line_start":97,"line_end":97,"column_start":13,"column_end":18,"is_primary":true,"text":[{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new(dim as usize)),","highlight_start":13,"highlight_end":18}],"label":"`agent_mem_db::AgentMemDB` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `agent_mem_db::AgentMemDB` has no field named `inner`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:97:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m97\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new(dim as usize)),\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"struct `agent_mem_db::AgentMemDB` has no field named `inner`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2759,"byte_end":2764,"line_start":105,"line_end":105,"column_start":13,"column_end":18,"is_primary":true,"text":[{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_exact(dim as usize)),","highlight_start":13,"highlight_end":18}],"label":"`agent_mem_db::AgentMemDB` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `agent_mem_db::AgentMemDB` has no field named `inner`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:105:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_exact(dim as usize)),\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"struct `agent_mem_db::AgentMemDB` has no field named `inner`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3024,"byte_end":3029,"line_start":113,"line_end":113,"column_start":13,"column_end":18,"is_primary":true,"text":[{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_with_max_elements(","highlight_start":13,"highlight_end":18}],"label":"`agent_mem_db::AgentMemDB` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `agent_mem_db::AgentMemDB` has no field named `inner`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:113:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m113\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_with_max_elements(\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"no field `inner` on type `&agent_mem_db::AgentMemDB`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3372,"byte_end":3377,"line_start":124,"line_end":124,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"        self.inner","highlight_start":14,"highlight_end":19}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `inner` on type `&agent_mem_db::AgentMemDB`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:124:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3546,"byte_end":3547,"line_start":128,"line_end":128,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":45,"highlight_end":46}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":3524,"byte_end":3525,"line_start":128,"line_end":128,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":3525,"byte_end":3525,"line_start":128,"line_end":128,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:128:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| Error::from_reason(e.to_string()))\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| Error::from_reason(e.to_string()))\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `inner` on type `&agent_mem_db::AgentMemDB`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3904,"byte_end":3909,"line_start":141,"line_end":141,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"            .inner","highlight_start":14,"highlight_end":19}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `inner` on type `&agent_mem_db::AgentMemDB`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:141:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .inner\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4509,"byte_end":4510,"line_start":155,"line_end":155,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))?;","highlight_start":45,"highlight_end":46}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":4487,"byte_end":4488,"line_start":155,"line_end":155,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":4488,"byte_end":4488,"line_start":155,"line_end":155,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))?;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:155:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| Error::from_reason(e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| Error::from_reason(e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `inner` on type `&agent_mem_db::AgentMemDB`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4730,"byte_end":4735,"line_start":163,"line_end":163,"column_start":14,"column_end":19,"is_primary":true,"text":[{"text":"            .inner","highlight_start":14,"highlight_end":19}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `inner` on type `&agent_mem_db::AgentMemDB`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:163:14\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .inner\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4911,"byte_end":4912,"line_start":167,"line_end":167,"column_start":45,"column_end":46,"is_primary":false,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":45,"highlight_end":46}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":4889,"byte_end":4890,"line_start":167,"line_end":167,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":4890,"byte_end":4890,"line_start":167,"line_end":167,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:167:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| Error::from_reason(e.to_string()))\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| Error::from_reason(e.to_string()))\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"struct `agent_mem_db::AgentMemDB` has no field named `inner`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":5210,"byte_end":5215,"line_start":176,"line_end":176,"column_start":13,"column_end":18,"is_primary":true,"text":[{"text":"            inner: std::sync::Mutex::new(db),","highlight_start":13,"highlight_end":18}],"label":"`agent_mem_db::AgentMemDB` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `agent_mem_db::AgentMemDB` has no field named `inner`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:176:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m176\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             inner: std::sync::Mutex::new(db),\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91m`agent_mem_db::AgentMemDB` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2418,"byte_end":2470,"line_start":93,"line_end":95,"column_start":6,"column_end":15,"is_primary":false,"text":[{"text":"impl AgentMemDB {","highlight_start":6,"highlight_end":18},{"text":"    #[napi(constructor)]","highlight_start":1,"highlight_end":25},{"text":"    pub fn new(dim: u32) -> Self {","highlight_start":1,"highlight_end":15}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":6830,"byte_end":6833,"line_start":228,"line_end":228,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(dim: usize) -> Self {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2412,"byte_end":2412,"line_start":92,"line_end":92,"column_start":8,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":8,"highlight_end":8}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `usize`, found `u32`\u001b[0m\n \u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   impl AgentMemDB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______-\u001b[0m\n \u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(constructor)]\n \u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: u32) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|______________-\u001b[0m \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: associated function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:228:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m228\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m| \u001b[0m#[napi]\u001b[92m.try_into().unwrap()\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[92m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `exact` found for struct `agent_mem_db::AgentMemDB` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2418,"byte_end":2706,"line_start":93,"line_end":103,"column_start":6,"column_end":12,"is_primary":false,"text":[{"text":"impl AgentMemDB {","highlight_start":6,"highlight_end":18},{"text":"    #[napi(constructor)]","highlight_start":1,"highlight_end":25},{"text":"    pub fn new(dim: u32) -> Self {","highlight_start":1,"highlight_end":35},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new(dim as usize)),","highlight_start":1,"highlight_end":87},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Create with exact (brute-force) search. O(n) per query.","highlight_start":1,"highlight_end":64},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn exact(dim: u32) -> Self {","highlight_start":1,"highlight_end":12}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2706,"byte_end":2711,"line_start":103,"line_end":103,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn exact(dim: u32) -> Self {","highlight_start":12,"highlight_end":17}],"label":"function or associated item not found in `agent_mem_db::AgentMemDB`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `agent_mem_db::AgentMemDB` consider using one of the following associated functions:\nagent_mem_db::AgentMemDB::new\nagent_mem_db::AgentMemDB::new_with_max_elements\nagent_mem_db::AgentMemDB::new_exact\nagent_mem_db::AgentMemDB::load_from_file","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":6823,"byte_end":6853,"line_start":228,"line_end":228,"column_start":5,"column_end":35,"is_primary":true,"text":[{"text":"    pub fn new(dim: usize) -> Self {","highlight_start":5,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":7004,"byte_end":7073,"line_start":233,"line_end":233,"column_start":5,"column_end":74,"is_primary":true,"text":[{"text":"    pub fn new_with_max_elements(dim: usize, max_elements: usize) -> Self {","highlight_start":5,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":7432,"byte_end":7468,"line_start":244,"line_end":244,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn new_exact(dim: usize) -> Self {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":12538,"byte_end":12603,"line_start":384,"line_end":384,"column_start":5,"column_end":70,"is_primary":true,"text":[{"text":"    pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {","highlight_start":5,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `new_exact` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2706,"byte_end":2711,"line_start":103,"line_end":103,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn exact(dim: u32) -> Self {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":"new_exact","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `exact` found for struct `agent_mem_db::AgentMemDB` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:103:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   impl AgentMemDB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______-\u001b[0m\n \u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(constructor)]\n \u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: u32) -> Self {\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Self {\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(factory)]\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn exact(dim: u32) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `agent_mem_db::AgentMemDB`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|___________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `agent_mem_db::AgentMemDB` consider using one of the following associated functions:\n      agent_mem_db::AgentMemDB::new\n      agent_mem_db::AgentMemDB::new_with_max_elements\n      agent_mem_db::AgentMemDB::new_exact\n      agent_mem_db::AgentMemDB::load_from_file\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:228:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m228\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new_with_max_elements(dim: usize, max_elements: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new_exact(dim: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m384\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `new_exact` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub fn \u001b[92mnew_\u001b[0mexact(dim: u32) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `with_max_elements` found for struct `agent_mem_db::AgentMemDB` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2418,"byte_end":2940,"line_start":93,"line_end":111,"column_start":6,"column_end":12,"is_primary":false,"text":[{"text":"impl AgentMemDB {","highlight_start":6,"highlight_end":18},{"text":"    #[napi(constructor)]","highlight_start":1,"highlight_end":25},{"text":"    pub fn new(dim: u32) -> Self {","highlight_start":1,"highlight_end":35},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new(dim as usize)),","highlight_start":1,"highlight_end":87},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Create with exact (brute-force) search. O(n) per query.","highlight_start":1,"highlight_end":64},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn exact(dim: u32) -> Self {","highlight_start":1,"highlight_end":37},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_exact(dim as usize)),","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Create with custom max_elements for scale.","highlight_start":1,"highlight_end":51},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn with_max_elements(dim: u32, max_elements: u32) -> Self {","highlight_start":1,"highlight_end":12}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2940,"byte_end":2957,"line_start":111,"line_end":111,"column_start":12,"column_end":29,"is_primary":true,"text":[{"text":"    pub fn with_max_elements(dim: u32, max_elements: u32) -> Self {","highlight_start":12,"highlight_end":29}],"label":"function or associated item not found in `agent_mem_db::AgentMemDB`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `agent_mem_db::AgentMemDB` consider using one of the following associated functions:\nagent_mem_db::AgentMemDB::new\nagent_mem_db::AgentMemDB::new_with_max_elements\nagent_mem_db::AgentMemDB::new_exact\nagent_mem_db::AgentMemDB::load_from_file","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":6823,"byte_end":6853,"line_start":228,"line_end":228,"column_start":5,"column_end":35,"is_primary":true,"text":[{"text":"    pub fn new(dim: usize) -> Self {","highlight_start":5,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":7004,"byte_end":7073,"line_start":233,"line_end":233,"column_start":5,"column_end":74,"is_primary":true,"text":[{"text":"    pub fn new_with_max_elements(dim: usize, max_elements: usize) -> Self {","highlight_start":5,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":7432,"byte_end":7468,"line_start":244,"line_end":244,"column_start":5,"column_end":41,"is_primary":true,"text":[{"text":"    pub fn new_exact(dim: usize) -> Self {","highlight_start":5,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":12538,"byte_end":12603,"line_start":384,"line_end":384,"column_start":5,"column_end":70,"is_primary":true,"text":[{"text":"    pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {","highlight_start":5,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `new_with_max_elements` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2940,"byte_end":2957,"line_start":111,"line_end":111,"column_start":12,"column_end":29,"is_primary":true,"text":[{"text":"    pub fn with_max_elements(dim: u32, max_elements: u32) -> Self {","highlight_start":12,"highlight_end":29}],"label":null,"suggested_replacement":"new_with_max_elements","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `with_max_elements` found for struct `agent_mem_db::AgentMemDB` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:111:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   impl AgentMemDB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______-\u001b[0m\n \u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(constructor)]\n \u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: u32) -> Self {\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Self {\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(factory)]\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn with_max_elements(dim: u32, max_elements: u32) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `agent_mem_db::AgentMemDB`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|___________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `agent_mem_db::AgentMemDB` consider using one of the following associated functions:\n      agent_mem_db::AgentMemDB::new\n      agent_mem_db::AgentMemDB::new_with_max_elements\n      agent_mem_db::AgentMemDB::new_exact\n      agent_mem_db::AgentMemDB::load_from_file\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:228:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m228\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m233\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new_with_max_elements(dim: usize, max_elements: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m244\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new_exact(dim: usize) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m384\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `new_with_max_elements` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    pub fn \u001b[92mnew_\u001b[0mwith_max_elements(dim: u32, max_elements: u32) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"expected `agent_mem_db::Episode`, found `Episode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":3253,"byte_end":3266,"line_start":122,"line_end":122,"column_start":12,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn store_episode(&self, episode: Episode) -> Result<()> {","highlight_start":12,"highlight_end":25}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Episode` and `agent_mem_db::Episode` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`Episode` is defined in the current crate","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":213,"byte_end":231,"line_start":8,"line_end":8,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Episode {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`agent_mem_db::Episode` is defined in crate `agent_mem_db`","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":1767,"byte_end":1785,"line_start":58,"line_end":58,"column_start":1,"column_end":19,"is_primary":true,"text":[{"text":"pub struct Episode {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":8049,"byte_end":8062,"line_start":264,"line_end":264,"column_start":12,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn store_episode(&mut self, episode: Episode) -> Result<(), AgentMemError> {","highlight_start":12,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `agent_mem_db::Episode`, found `Episode`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn store_episode(&self, episode: Episode) -> Result<()> {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `Episode` and `agent_mem_db::Episode` have similar names, but are actually distinct types\n\u001b[1m\u001b[92mnote\u001b[0m: `Episode` is defined in the current crate\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Episode {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `agent_mem_db::Episode` is defined in crate `agent_mem_db`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:58:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Episode {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:264:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m264\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn store_episode(&mut self, episode: Episode) -> Result<(), AgentMemError> {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `JsError<_>: From<AgentMemError>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`\nbut trait `From<napi::Error<_>>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `napi::Error<_>`, found `AgentMemError`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `JsError<_>: From<AgentMemError>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<AgentMemError>` is not implemented for `JsError<_>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `From<\u001b[1m\u001b[35mAgentMemError\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `JsError<_>`\n           but trait `From<\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m`, found `\u001b[1m\u001b[35mAgentMemError\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3744,"byte_end":3752,"line_start":135,"line_end":135,"column_start":20,"column_end":28,"is_primary":true,"text":[{"text":"        embedding: Vec<f32>,","highlight_start":20,"highlight_end":28}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:135:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         embedding: Vec<f32>,\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n              f64\n              i16\n              i32\n              i64\n              i8\n              u16\n              u32\n              u8\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Vec<f32>` to implement `napi::bindgen_prelude::FromNapiValue`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":3774,"byte_end":3777,"line_start":136,"line_end":136,"column_start":21,"column_end":24,"is_primary":true,"text":[{"text":"        min_reward: f32,","highlight_start":21,"highlight_end":24}],"label":"the trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n  f64\n  i16\n  i32\n  i64\n  i8\n  u16\n  u32\n  u8","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `f32: napi::bindgen_prelude::FromNapiValue` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:136:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         min_reward: f32,\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `napi::bindgen_prelude::FromNapiValue` is not implemented for `f32`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `napi::bindgen_prelude::FromNapiValue`:\n              f64\n              i16\n              i32\n              i64\n              i8\n              u16\n              u32\n              u8\n\n"}
{"$message_type":"diagnostic","message":"this method takes 3 arguments but 4 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"expected `usize`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"unexpected argument #4 of type `Option<QueryOptionsJs>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":3695,"byte_end":3708,"line_start":133,"line_end":133,"column_start":12,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn query_similar(","highlight_start":12,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `&[f32]`, found `Vec<f32>`","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"expected reference `&[f32]`\n      found struct `Vec<f32>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":9300,"byte_end":9313,"line_start":295,"line_end":295,"column_start":12,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn query_similar(","highlight_start":12,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `usize` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":2412,"byte_end":2412,"line_start":92,"line_end":92,"column_start":8,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":8,"highlight_end":8}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 3 arguments but 4 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:133:12\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94mexpected `usize`, found `u32`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94munexpected argument #4 of type `Option<QueryOptionsJs>`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m133\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn query_similar(\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `&[f32]`, found `Vec<f32>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected reference `\u001b[1m\u001b[35m&[f32]\u001b[0m`\n                  found struct `\u001b[1m\u001b[35mVec<f32>\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:295:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m295\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn query_similar(\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m| \u001b[0m#[napi]\u001b[92m.try_into().unwrap()\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[92m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Vec<agent_mem_db::Episode>: ToNapiValue` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"the trait `ToNapiValue` is not implemented for `Vec<agent_mem_db::Episode>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `ToNapiValue`:\n  &Vec<T>\n  &mut Vec<T>\n  Vec<T>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Vec<agent_mem_db::Episode>: ToNapiValue` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `ToNapiValue` is not implemented for `Vec<agent_mem_db::Episode>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `ToNapiValue`:\n             &Vec<T>\n             &mut Vec<T>\n             Vec<T>\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `JsError<_>: From<AgentMemError>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`\nbut trait `From<napi::Error<_>>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `napi::Error<_>`, found `AgentMemError`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `JsError<_>: From<AgentMemError>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<AgentMemError>` is not implemented for `JsError<_>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `From<\u001b[1m\u001b[35mAgentMemError\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `JsError<_>`\n           but trait `From<\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m`, found `\u001b[1m\u001b[35mAgentMemError\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"expected `&Path`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":4645,"byte_end":4657,"line_start":161,"line_end":161,"column_start":12,"column_end":24,"is_primary":false,"text":[{"text":"    pub fn save_to_file(&self, path: String) -> Result<()> {","highlight_start":12,"highlight_end":24}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":11922,"byte_end":11934,"line_start":370,"line_end":370,"column_start":12,"column_end":24,"is_primary":true,"text":[{"text":"    pub fn save_to_file(&self, path: &Path) -> Result<(), AgentMemError> {","highlight_start":12,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Path`, found `String`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m161\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn save_to_file(&self, path: String) -> Result<()> {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94marguments to this method are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:370:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn save_to_file(&self, path: &Path) -> Result<(), AgentMemError> {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `JsError<_>: From<AgentMemError>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`\nbut trait `From<napi::Error<_>>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `napi::Error<_>`, found `AgentMemError`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `JsError<_>: From<AgentMemError>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<AgentMemError>` is not implemented for `JsError<_>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `From<\u001b[1m\u001b[35mAgentMemError\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `JsError<_>`\n           but trait `From<\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m`, found `\u001b[1m\u001b[35mAgentMemError\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"expected `&Path`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":2418,"byte_end":5009,"line_start":93,"line_end":172,"column_start":6,"column_end":26,"is_primary":false,"text":[{"text":"impl AgentMemDB {","highlight_start":6,"highlight_end":18},{"text":"    #[napi(constructor)]","highlight_start":1,"highlight_end":25},{"text":"    pub fn new(dim: u32) -> Self {","highlight_start":1,"highlight_end":35},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new(dim as usize)),","highlight_start":1,"highlight_end":87},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Create with exact (brute-force) search. O(n) per query.","highlight_start":1,"highlight_end":64},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn exact(dim: u32) -> Self {","highlight_start":1,"highlight_end":37},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_exact(dim as usize)),","highlight_start":1,"highlight_end":93},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Create with custom max_elements for scale.","highlight_start":1,"highlight_end":51},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn with_max_elements(dim: u32, max_elements: u32) -> Self {","highlight_start":1,"highlight_end":68},{"text":"        Self {","highlight_start":1,"highlight_end":15},{"text":"            inner: std::sync::Mutex::new(agent_mem_db::AgentMemDB::new_with_max_elements(","highlight_start":1,"highlight_end":90},{"text":"                dim as usize,","highlight_start":1,"highlight_end":30},{"text":"                max_elements as usize,","highlight_start":1,"highlight_end":39},{"text":"            )),","highlight_start":1,"highlight_end":16},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Store an episode.","highlight_start":1,"highlight_end":26},{"text":"    #[napi]","highlight_start":1,"highlight_end":12},{"text":"    pub fn store_episode(&self, episode: Episode) -> Result<()> {","highlight_start":1,"highlight_end":66},{"text":"        let rust_ep: RustEpisode = episode.into();","highlight_start":1,"highlight_end":51},{"text":"        self.inner","highlight_start":1,"highlight_end":19},{"text":"            .lock()","highlight_start":1,"highlight_end":20},{"text":"            .map_err(|e| Error::from_reason(format!(\"lock: {e}\")))?","highlight_start":1,"highlight_end":68},{"text":"            .store_episode(rust_ep)","highlight_start":1,"highlight_end":36},{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Query for similar episodes. embedding: number[], min_reward, top_k. Optional opts for filters.","highlight_start":1,"highlight_end":103},{"text":"    #[napi]","highlight_start":1,"highlight_end":12},{"text":"    pub fn query_similar(","highlight_start":1,"highlight_end":26},{"text":"        &self,","highlight_start":1,"highlight_end":15},{"text":"        embedding: Vec<f32>,","highlight_start":1,"highlight_end":29},{"text":"        min_reward: f32,","highlight_start":1,"highlight_end":25},{"text":"        top_k: u32,","highlight_start":1,"highlight_end":20},{"text":"        opts: Option<QueryOptionsJs>,","highlight_start":1,"highlight_end":38},{"text":"    ) -> Result<Vec<Episode>> {","highlight_start":1,"highlight_end":32},{"text":"        let db = self","highlight_start":1,"highlight_end":22},{"text":"            .inner","highlight_start":1,"highlight_end":19},{"text":"            .lock()","highlight_start":1,"highlight_end":20},{"text":"            .map_err(|e| Error::from_reason(format!(\"lock: {e}\")))?;","highlight_start":1,"highlight_end":69},{"text":"        let query_opts = opts","highlight_start":1,"highlight_end":30},{"text":"            .map(|o| {","highlight_start":1,"highlight_end":23},{"text":"                let mut q = QueryOptions::new(o.min_reward, o.top_k as usize);","highlight_start":1,"highlight_end":79},{"text":"                q.tags_any = o.tags_any;","highlight_start":1,"highlight_end":41},{"text":"                q.time_after = o.time_after;","highlight_start":1,"highlight_end":45},{"text":"                q.time_before = o.time_before;","highlight_start":1,"highlight_end":47},{"text":"                q","highlight_start":1,"highlight_end":18},{"text":"            })","highlight_start":1,"highlight_end":15},{"text":"            .unwrap_or_else(|| QueryOptions::new(min_reward, top_k as usize));","highlight_start":1,"highlight_end":79},{"text":"        let results = db","highlight_start":1,"highlight_end":25},{"text":"            .query_similar_with_options(&embedding, query_opts)","highlight_start":1,"highlight_end":64},{"text":"            .map_err(|e| Error::from_reason(e.to_string()))?;","highlight_start":1,"highlight_end":62},{"text":"        Ok(results.into_iter().map(Episode::from).collect())","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Save to JSON file.","highlight_start":1,"highlight_end":27},{"text":"    #[napi]","highlight_start":1,"highlight_end":12},{"text":"    pub fn save_to_file(&self, path: String) -> Result<()> {","highlight_start":1,"highlight_end":61},{"text":"        let db = self","highlight_start":1,"highlight_end":22},{"text":"            .inner","highlight_start":1,"highlight_end":19},{"text":"            .lock()","highlight_start":1,"highlight_end":20},{"text":"            .map_err(|e| Error::from_reason(format!(\"lock: {e}\")))?;","highlight_start":1,"highlight_end":69},{"text":"        db.save_to_file(Path::new(&path))","highlight_start":1,"highlight_end":42},{"text":"            .map_err(|e| Error::from_reason(e.to_string()))","highlight_start":1,"highlight_end":60},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Load from JSON file.","highlight_start":1,"highlight_end":29},{"text":"    #[napi(factory)]","highlight_start":1,"highlight_end":21},{"text":"    pub fn load_from_file(path: String) -> Result<Self> {","highlight_start":1,"highlight_end":26}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs","byte_start":12545,"byte_end":12559,"line_start":384,"line_end":384,"column_start":12,"column_end":26,"is_primary":true,"text":[{"text":"    pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {","highlight_start":12,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   #[napi]\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Path`, found `String`\u001b[0m\n \u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   impl AgentMemDB {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ______-\u001b[0m\n \u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(constructor)]\n \u001b[1m\u001b[94m95\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new(dim: u32) -> Self {\n \u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Self {\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m171\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     #[napi(factory)]\n\u001b[1m\u001b[94m172\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn load_from_file(path: String) -> Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________________________-\u001b[0m \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: associated function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/sathvikkurapati/Downloads/agenticmemory/agent_mem_db/src/lib.rs:384:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m384\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn load_from_file(path: &Path) -> Result<Self, AgentMemError> {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `JsError<_>: From<AgentMemError>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":true,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":2405,"byte_end":2412,"line_start":92,"line_end":92,"column_start":1,"column_end":8,"is_primary":false,"text":[{"text":"#[napi]","highlight_start":1,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[napi]","def_site_span":{"file_name":"/Users/sathvikkurapati/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/napi-derive-3.5.2/src/lib.rs","byte_start":465,"byte_end":530,"line_start":27,"line_end":27,"column_start":1,"column_end":66,"is_primary":false,"text":[{"text":"pub fn napi(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":66}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `From<AgentMemError>` is not implemented for `JsError<_>`\nbut trait `From<napi::Error<_>>` is implemented for it","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `napi::Error<_>`, found `AgentMemError`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `JsError<_>: From<AgentMemError>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:92:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[napi]\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<AgentMemError>` is not implemented for `JsError<_>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `From<\u001b[1m\u001b[35mAgentMemError\u001b[0m>` \u001b[1m\u001b[35mis not\u001b[0m implemented for `JsError<_>`\n           but trait `From<\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m>` \u001b[1m\u001b[35mis\u001b[0m implemented for it\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: for that trait implementation, expected `\u001b[1m\u001b[35mnapi::Error<_>\u001b[0m`, found `\u001b[1m\u001b[35mAgentMemError\u001b[0m`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the attribute macro `napi` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 42 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 42 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0116, E0117, E0255, E0277, E0282, E0308, E0560, E0599...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0116, E0117, E0255, E0277, E0282, E0308, E0560, E0599...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
